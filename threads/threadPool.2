ns Org {
ns Div {
// PRIVATE MANIPULATORS
void ThreadPool::workerThread()
{
    d_barrier.wait();  // initial synchronization in 'start'

    Job functor;
    do {
        if (_drainFlag) {
            _barrier.wait();  // pool threads acknowledge drain
            _barrier.wait();  // pool threads may proceed
        }
        while (0 == _queue.popFront(&functor)) {
            _activeThreads.fetch_add(1,memory_order_acq_rel);
            functor();                                               //EXEC
            functor = nullptr;  // ensure destructor is called
            _activeThreads.fetch_sub(1,memory_order_acq_rel);
        }
    } while (_drainFlag);
}

int ThreadPool::startNewThread()
{
    function<void()> workerThreadFunc = bind(&ThreadPool::workerThread, this);
    int rc = _threadGroup.addThread(workerThreadFunc, _threadAttributes);
    return rc;
}

// CREATORS
ThreadPool::ThreadPool(int  numThreads,
                       int  maxPendingJobs)
: _queue(maxPendingJobs)
, _activeThreads(0)
, _drainFlag(false)
, _barrier(numThreads + 1) //number of participating threads
, _threadGroup(basicAllocator)
, _threadAttributes()
, _totalThreads(numThreads)
{
    BSLS_ASSERT_OPT(1 <= numThreads);
}


// MANIPULATORS
int ThreadPool::start()
{
    LockGuard<Mutex> lock(&_metaMutex);
    if (!_queue.isPopFrontDisabled()) {//already started
        return 0;                                                    // RETURN  
    }
    for (int i = 0; i < _totalThreads; ++i)  {
        if (0 != startNewThread()) {
            //fail: release all threads by _totalThreads + 1 arrivals to the barrier 
            for (int j = i ; j <= _totalThreads; ++j) {
                _barrier.arrive();
            }
            _threadGroup.joinAll();
            return -1;                                                // RETURN
        }
    }
    //success: enable enqueuing
    _queue.enablePopFront();
    _queue.enablePushBack();

    _barrier.wait();

    return 0;
}






inline
void ThreadPool::drain()
{
    LockGuard<Mutex> lock(&_metaMutex);

    if (isStarted()) {
        _queue.waitUntilEmpty();

        _drainFlag = true;
        _queue.disablePopFront();
        _barrier.wait();

        _drainFlag = false;
        _queue.enablePopFront();
        _barrier.wait();
    }
}

inline
void ThreadPool::shutdown()
{
    bslmt::LockGuard<bslmt::Mutex> lock(&_metaMutex);

    if (isStarted()) {
        _queue.disablePushBack();
        _queue.disablePopFront();
        _threadGroup.joinAll();
        _queue.removeAll();
    }
}

inline
void FixedThreadPool::stop()
{
    bslmt::LockGuard<bslmt::Mutex> lock(&d_metaMutex);

    if (isStarted()) {
        d_queue.disablePushBack();
        d_queue.waitUntilEmpty();
        d_queue.disablePopFront();
        d_threadGroup.joinAll();
    }
}

// ACCESSORS
inline
bool FixedThreadPool::isEnabled() const
{
    return !d_queue.isPushBackDisabled();
}

bool FixedThreadPool::isStarted() const
{
    return d_numThreads == d_threadGroup.numThreads();
}

int FixedThreadPool::numActiveThreads() const
{
    return d_numActiveThreads.loadAcquire();
}

int FixedThreadPool::numPendingJobs() const
{
    return static_cast<int>(d_queue.numElements());
}

int FixedThreadPool::numThreads() const
{
    return d_numThreads;
}

int FixedThreadPool::numThreadsStarted() const
{
    return d_threadGroup.numThreads();
}

int FixedThreadPool::queueCapacity() const
{
    return static_cast<int>(d_queue.capacity());
}

}
}
